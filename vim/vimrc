set t_Co=256 " 256 colors
" set UTF-8 encoding
set enc=utf-8
set fenc=utf-8
set termencoding=utf-8
" disable vi compatibility (emulation of old bugs)
set nocompatible
filetype off
set backspace=2         " make backspace working
" use indentation of previous line
set autoindent
" use intelligent indentation for C
set smartindent
" configure tabwidth and insert spaces instead of tabs
set tabstop=4        " tab width is 4 spaces
set shiftwidth=4     " indent also with 4 spaces
set expandtab        " expand tabs to spaces
set wrap
set ruler               " show the line number on the bar
set colorcolumn=80      " color column
" turn syntax highlighting on
syntax on
" search settings
set hlsearch
set incsearch
set ignorecase " ignore case when searching...
set smartcase " but change it when at lease on uppercase letter is given
" turn line numbers on
set relativenumber      " relative line numbering to simplyfy moving
set number              " normal line number
set showmatch           " show matching brackets
" intelligent comments
set comments=sl:/*,mb:\ *,elx:\ */
" split settings
set splitbelow
set splitright
" show all possible matches when using autocomplete in command-lie
set wildmenu

" The /g flag on :s substitutions by default
set gdefault

set clipboard+=unnamed " enable clipboard register support

"options for GUI - remove all :)
set go-=m "remove menu bar
set go-=T "remove toolbar
set go-=r "remove right scroll bar
set go-=L "remove left scroll bar

set nobackup            " disable backup files
set noswapfile          " disable swap files

"so types.vim            " try to highlight user defined types

autocmd FileType Makefile expandtab off "tabs in Makefile

set autoread
set nobackup
set nowb
set undofile
set undodir=$HOME/.vim/undodir

" status bar stuff
set laststatus=2        " show status line all the time
let g:airline_theme = "base16"
let g:airline_powerline_fonts = 1
let g:airline#extensions#tabline#enabled = 1

" silver_searcher as default grep
set grepprg=ag\ --vimgrep\ $*
set grepformat=%f:%l:%c:%m

function! GetRepoRoot()
    return systemlist('dirname $(git rev-parse --git-dir 2>/dev/null)')[0]
endfun

function! GrepInNewTab(needle, haystack, additinalAgArgs)
    let regexp = "\"\\b" . a:needle . "\\b\""
    let agArgs = "--case-sensitive " . a:additinalAgArgs
    execute ":tabnew"
    execute ":grep -R " . regexp . " " . a:haystack . " " . agArgs
    execute ":copen"
    norm [Q
endfun

nmap <leader>g <leader>G<CR>
nmap <leader>G :call GrepInNewTab("<C-r><C-w>", "<C-r>=GetRepoRoot()<CR>", "")

" move cursor by display line
nnoremap j gj
nnoremap k gk

" watch out for SHIFT key
:command Q q
:command W w
:command QA qall
:command Qa qall
:command Xa xall
:command XA xall

" shortcuts for system clipboard
nnoremap <leader>y "+y
nnoremap <leader>p "+p
vnoremap <leader>y "+y
vnoremap <leader>p "+p


" backspace removes highlight after search
nnoremap <Enter> :noh<CR>
autocmd FileType qf nnoremap <buffer> <Enter> <Enter>

function IAmPro()
    " disable arrow keys in Normal mode
    map <up> <nop>
    map <down> <nop>
    map <left> :bprev<CR>
    map <right> :bnext<CR>

    " disable arrow keys in Insert mode
    imap <up> <nop>
    imap <down> <nop>
    imap <left> <nop>
    imap <right> <nop>
endfun

function! IAmNoob()
    map <up> <up>
    map <down> <down>
    map <left> <left>
    map <right> <right>

    " disable arrow keys in Insert mode
    imap <up> <up>
    imap <down> <down>
    imap <left> <left>
    imap <right> <right>
endfun

call IAmPro() " I am pro by default

command IAmNoob call IAmNoob()
command IAmPro call IAmPro()

" folding
set foldmethod=indent   
set foldnestmax=10
set nofoldenable
set foldlevel=2
" my snippets
set runtimepath +=~/aginoodle/

" Use perl compiler for all *.pl and *.pm files.
autocmd BufNewFile,BufRead *.p? compiler perl

" remove trailing whitspaes on file save
fun! <SID>StripTrailingWhitespaces()
    let l = line(".")
    let c = col(".")
    %s/\s\+$//e
    call cursor(l, c)
endfun

autocmd FileType c,cpp,java,php,ruby,python,javascript,html,tex,css autocmd BufWritePre <buffer> :call <SID>StripTrailingWhitespaces()
au BufReadPost *.tex setlocal spell spelllang=pl

" set the runtime path to include Vundle and initialize
set rtp+=~/.vim/bundle/Vundle.vim
call vundle#begin()

" plugins
Plugin 'gmarik/Vundle.vim'
Plugin 'tpope/vim-unimpaired'
Plugin 'bling/vim-airline'
Plugin 'vim-airline/vim-airline-themes'
Plugin 'ctrlpvim/ctrlp.vim'
Plugin 'moll/vim-bbye'
Plugin 'rhysd/devdocs.vim'

:nnoremap <Leader>k :DevDocsAll 
:nnoremap <Leader>K :DevDocsAllUnderCursor

" keyboard shortcut to close buffer, but preserve window layout
:nnoremap <Leader>Q :Bdelete<CR>
:nnoremap <Leader>q :bd<CR>

" ignored directories 
set wildignore+=*/eggs/*,*/backups/*,*/bin/*,*/bootstrap.py/*,*/build/*,*/buildout.cfg/*,*/develop-eggs/*,*/parts/*,*/logs/*,*/docs/*,*/src/backlog.egg-info/*,*/collected-statics/*,*.pyc

Bundle 'tomtom/tcomment_vim'
Bundle 'vim-scripts/ZoomWin'
Plugin 'chriskempson/base16-vim'
Bundle 'wellle/targets.vim'
Plugin 'sheerun/vim-polyglot'
Plugin 'scrooloose/syntastic'

" syntastic settings
set statusline+=%#warningmsg#
set statusline+=%{SyntasticStatuslineFlag()}
set statusline+=%*

let g:syntastic_always_populate_loc_list = 1
let g:syntastic_enable_signs = 0
let g:syntastic_python_pylint_exec = $WORKSPACE . '/bin/pylint-run'

" tmux integration
Plugin 'christoomey/vim-tmux-navigator'

" snipmate
Bundle "MarcWeber/vim-addon-mw-utils"
Bundle "tomtom/tlib_vim"
Bundle "garbas/vim-snipmate"

" user snippet repository
Bundle "honza/vim-snippets"

" run commands in tmux split
Plugin 'benmills/vimux'
let g:VimuxUseNearest = 0

call vundle#end()            " required
filetype plugin indent on    " required

" colorscheme settings
let base16colorspace=256
colorscheme base16-default-dark
set background=dark

" ctrlp tag fuzzy search
nnoremap <C-t> :CtrlPTag<CR>

" aginoodle test running
let g:RunTestCommand = $WORKSPACE . '/bin/py.test --reuse-db'

nmap <leader>a :cd $WORKSPACE<CR>

function! RunTest()
    let l:winview = winsaveview()
    execute '?def test'
    normal w
    let command = g:RunTestCommand . ' ' . expand('%') . ' -k ' . expand('<cword>')
    call winrestview(l:winview)
    execute 'nohlsearch'
    execute RunCommand(command)
    call winrestview(l:winview)
endfunction

function! RunTestFile()
    execute RunCommand(g:RunTestCommand . ' ' . expand('%'))
endfunction

function! RunCommand(command)
    normal m'
    let executed = 'script -c "' . a:command . '" /tmp/tests.log'
    if exists(":VimuxRunCommand")
        execute VimuxRunCommand(l:executed)
    else
        execute '!' . ' ' . a:command
    endif
endfunction

map <leader>T :call RunTestFile()<CR>
map <leader>t :call RunTest()<CR>

set errorformat=file\ %f\ line\ %l\ msg\ %m

function! ParseFailures(stdout)
    " Pointers and default variables
    let failed = 0
    let errors = {}
    let stacktrace = []
    let error = {}
    let error_number = -1
    let saving_in_progress = 0
    let pytest_error = ""
    let current_file = expand("%:t")
    let file_regex =  '\v(^' . current_file . '|/' . current_file . ')'
    let error['line'] = ""
    let error['path'] = ""
    let error['exception'] = ""

    " Loop through the output and build the error dict
    for w in a:stdout
        if w =~ '\v_{5,}'
            if saving_in_progress == 1
                let error.stacktrace = stacktrace
                let errors[error_number] = error
            endif
            let error_number = error_number + 1
            let saving_in_progress = 1
            let error = {}
            let error['line'] = ""
            let error['path'] = ""
            let error['exception'] = ""
            let stacktrace = []
        endif

        if w =~ '\v-{5,}'
            let error.stacktrace = stacktrace
            let errors[error_number] = error
            let error = {}
            let error['line'] = ""
            let error['path'] = ""
            let error['exception'] = ""
            let saving_in_progress = 0
            let stacktrace = []
        endif
        if w =~ '\v(\d+) failed'
            " sometimes last error on error list has no server output
            " in such sytuation error ends with test summary line
            let error.stacktrace = stacktrace
            if saving_in_progress == 1
                let errors[error_number] = error
            endif
            let error = {}
            let error['line'] = ""
            let error['path'] = ""
            let error['exception'] = ""
            let stacktrace = []
        endif

        if w =~ '\v\s+(FAILURES)\s+'
            let failed = 1
        elseif w =~ '\v^(.*)\.py:(\d+):'
            if w =~ file_regex
                let match_result = matchlist(w, '\v:(\d+):')
                let error.line = match_result[1]
                let file_path = matchlist(w, '\v(.*.py):')
                let error.path = file_path[1]
                call add(stacktrace, {'path': file_path[1], 'line': match_result[1]})
            elseif w !~ file_regex
                " Because we have missed out on actual line and path
                " add them here to both file_line and line and file_path and
                " path so that reporting works
                let match_result = matchlist(w, '\v:(\d+):')
                let error.file_line = match_result[1]
                let error.line = match_result[1]
                let file_path = matchlist(w, '\v(.*.py):')
                let error.file_path = file_path[1]
                let error.path = file_path[1]
                call add(stacktrace, {'path': file_path[1], 'line': match_result[1]})
            endif
        elseif w =~  '\v^E\s+\w+(.*)\s+'
            let split_error = split(w, "E ")
            let actual_error = substitute(split_error[0],"^\\s\\+\\|\\s\\+$","","g")
            let match_error = matchlist(actual_error, '\v(\w+):\s+(.*)')
            if (len(match_error))
                let error.exception = match_error[1]
                let error.error = match_error[2]
            else
                let error.error = error.error . actual_error
            endif
        elseif w =~ '\v^(.*)\s*ERROR:\s+'
            let pytest_error = w
        endif

    endfor

    " Display the result
    if (failed == 1)
        let g:pytest_session_errors = errors
        let g:quickfix_errors_source = []
        for error_number in keys(errors)
            let path = errors[error_number].stacktrace[0].path
            let line = errors[error_number].stacktrace[0].line
            let msg = errors[error_number].exception . ' ' . errors[error_number].error
            let full = 'file ' . path . ' line ' . line . ' msg ' . msg
            call add(g:quickfix_errors_source, full)
        endfor
        cexpr g:quickfix_errors_source
    endif
endfunction

function! ShowTestErrors()
    let nonused = system('sed -i "s/[^m]*m//g" /tmp/tests.log')
    let nonused = system('col -bp < /tmp/tests.log > /tmp/tests_cleaned.log')
    execute ParseFailures(readfile('/tmp/tests_cleaned.log'))
    cfirst
    let g:displayed_error_number = 0
    let g:stacktrace_level = 0
endfunction

function! GoToStacktraceLevel(level_number)
    let g:stacktrace_level = a:level_number
    let current_stacktrace = g:pytest_session_errors[g:displayed_error_number].stacktrace
    let target_level = current_stacktrace[g:stacktrace_level]
    let path = target_level.path
    let line = target_level.line
    
    execute ':edit ' . path
    execute ':' . line
endfunction

function! GoToLastLevelInStacktrace()
    let current_stacktrace = g:pytest_session_errors[g:displayed_error_number].stacktrace
    let last_stacktrace_level = len(current_stacktrace) - 1
    call GoToStacktraceLevel(last_stacktrace_level)
endfunction

function! GoToError(error_number)
    let g:stacktrace_level = 0
    let g:displayed_error_number = a:error_number

    execute ':cc ' . a:error_number
endfunction

nmap <leader>p :call ShowTestErrors()<CR>
nmap ]s :call GoToStacktraceLevel(g:stacktrace_level + 1)<CR>
nmap ]S :call GoToLastLevelInStacktrace()<CR>
nmap [s :call GoToStacktraceLevel(g:stacktrace_level - 1)<CR>
nmap [S :call GoToStacktraceLevel(0)<CR>

nmap [q :call GoToError(g:displayed_error_number - 1)<CR>
nmap [Q :call GoToError(0)<CR>
nmap ]q :call GoToError(g:displayed_error_number + 1)<CR>
"nmap ]Q :call GoToLastError()<CR>
